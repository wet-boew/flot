<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>WxT Flot Examples: Categories</title>
	<link href="../examples.css" rel="stylesheet" type="text/css">
	<!--[if lte IE 8]><script language="javascript" type="text/javascript" src="../../excanvas.min.js"></script><![endif]-->
	<script language="javascript" type="text/javascript" src="../../jquery.js"></script>
	<script language="javascript" type="text/javascript" src="../../jquery.flot.js"></script>
	<script language="javascript" type="text/javascript" src="../../jquery.flot.categories.js"></script>
	<script language="javascript" type="text/javascript" src="../../parserTable.js"></script>
	<script type="text/javascript">
/*
	$(function() {
		var data = [ ["January", 10], ["February", 8], ["March", 4], ["April", 13], ["May", 17], ["June", 9] ];

		$.plot("#placeholder", [ data ], {
			series: {
				bars: {
					show: true,
					barWidth: 0.6,
					align: "center"
				}
			},
			xaxis: {
				mode: "categories",
				tickLength: 0
			}
		});

		// Add the Flot version string to the footer

		$("#footer").prepend("Flot " + $.plot.version + " &ndash; ");
	});
*/
	(function ($) {
    $(document).ready(function() {

function getCellValue(cellRawValue) {
	//trim spaces in the string;
	cellRawValue = cellRawValue.replace(/\s\s+/g, " ");
	cellRawValue = cellRawValue.replace(/^\s+|\s+$/g, "");
	// Return the result
	var result = {
	cellUnit: cellRawValue.match(/[^\+\-\.\, 0-9]+[^\-\+0-9]*/), // Type: Float - Hint: You can use the JS function "parseFloat(string)"
	cellValue: parseFloat(cellRawValue.match(/[\+\-0-9]+[0-9,\. ]*/)) // Type: String
	};
	return result;
}
        var _pe = window.pe || {
            fn : {}
        },
			colorsAccent = ["#8d201c", "#EE8310", "#2a7da6", "#5a306b", "#285228", "#154055", "#555555", "#f6d200", "#d73d38", "#418541", "#87aec9", "#23447e", "#999999"];


		function addTblHeaders(tblparser) {

			// Set ID and Header for the table head
			for (i = 0; i < tblparser.theadRowStack.length; i += 1) {
				currRow = tblparser.theadRowStack[i];
			
				for (j = 0; j < currRow.cell.length; j += 1) {
					currCell = currRow.cell[j];
				
					if ((currCell.type === 1 || currCell.type === 7) && (
							!(j > 0 && currCell.uid === currRow.cell[j - 1].uid) &&
							!(i > 0 && currCell.uid === tblparser.theadRowStack[i - 1].cell[j].uid)
						) ) {
					
						if (!currCell.header) { // Imediate header
							currCell.header = [];
						}
						if (!currCell.headers) { // all the headers
							currCell.headers = [];
						}
						
						if (!currCell.child) { // Imediate sub cell
							currCell.child = [];
						}
						if (!currCell.childs) { // All the sub cell
							currCell.childs = [];
						}
					
						// Set the header of the current cell if required
						if (i > 0) {
							// All the header cells
							$.each(tblparser.theadRowStack[i - 1].cell[j].header, function() {
								currCell.headers.push(this);
								this.childs.push(currCell);
							});
							// Imediate header cell
							currCell.headers.push(tblparser.theadRowStack[i - 1].cell[j]);
							currCell.header.push(tblparser.theadRowStack[i - 1].cell[j]);
							tblparser.theadRowStack[i - 1].cell[j].child.push(currCell);
						}
					
					
						// Set the header on his descriptive cell if any 
						if (currCell.descCell) {
							currCell.descCell.header = currCell;
							currCell.descCell.headers = currCell;
						}
					}
				
				}
			
			}
			
			// TODO: Use "concat" instead of "push"
			
			// return;
			
			// Set Id/headers for header cell and data cell in the table.
					for (i = 0; i < tblparser.row.length; i += 1) {
						currRow = tblparser.row[i];
						var rowheadersgroup = [],
							rowheaders = [],
							currrowheader = [];
							ongoingRowHeader = [];
						
						// Get or Generate a unique ID for each header in this row
						if (currRow.headerset && !currRow.idsheaderset) { 
							for (j = 0; j < currRow.headerset.length; j += 1) {
								rowheadersgroup.push(currRow.headerset[j]);
							}
							currRow.idsheaderset = rowheadersgroup;
						}
						
						if (currRow.header) { 
							for (j = 0; j < currRow.header.length; j += 1) {
								rowheaders.push(currRow.header[j]);
							}
						}
						rowheaders = (currRow.idsheaderset ? currRow.idsheaderset + ' ' + rowheaders : rowheaders);
						for (j = 0; j < currRow.cell.length; j += 1) {
							
							if ((j === 0) || (j > 0 && currRow.cell[j].uid !== currRow.cell[(j - 1)].uid)){
								var currCell = currRow.cell[j],
									coldataheader = [];
								
								if (!currCell.header) { // Imediate header
									currCell.header = [];
								}
								if (!currCell.headers) { // all the headers
									currCell.headers = [];
								}
								
								
								if (currCell.col && !currCell.col.dataheader) {
									var currCol = currCell.col;
									var colheaders = [],
										colheadersgroup = [];
									if (currCol.headerLevel) { 
										for (m = 0; m < currCol.headerLevel.length; m += 1) {
											colheadersgroup.push(currCol.headerLevel[m]);
										}
									}
									if (currCol.header) { 
										for (m = 0; m < currCol.header.length; m += 1) {
											colheaders.push(currCol.header[m]);
										}
									}
									
									if(!currCol.dataheader) {
										currCol.dataheader = [];
									}

									currCol.dataheader.push(colheadersgroup);
									currCol.dataheader.push(colheaders);
								}
								
								if (currCell.col && currCell.col.dataheader) {
									coldataheader = currCell.col.dataheader;
								}
								
								
								
								if (currCell.type === 1) {
									
									currCell.header.push(ongoingRowHeader); // clone of ????
									
									currCell.headers.push(coldataheader);
									currCell.headers.push(currRow.idsheaderset);
									currCell.headers.push(ongoingRowHeader); // clone of ????

									ongoingRowHeader.push(currCell);
								}
								
								
								if (currCell.type === 2 || currCell.type === 3) {
									
									// Get Current Column Headers
									currrowheader = rowheaders;
									
									if (currCell.addcolheaders) {
										for (m = 0; m < currCell.addcolheaders.length; m += 1) {
											coldataheader.push(currCell.addcolheaders[m]);
										}
									}
									
									if (currCell.addrowheaders) {
										for (m = 0; m < currCell.addrowheaders.length; m += 1) {
											currrowheader.push(currCell.addrowheaders[m]);
										}
									}
									
									
									currCell.headers.push(coldataheader);
									currCell.headers.push(currrowheader);

									currCell.header = currCell.headers;
									
								}
								
								if (currCell.type === 4 || currCell.type === 5) {
									var descHeaders = "";
									
									if (currCell.describe) {
										for (m = 0; m < currCell.describe.length; m += 1) {
											var currCellId = $(currCell.describe[m].elem).attr('id');
											if (currCellId === undefined || currCellId === '' || resetIds) {
												// currCellId = idPrefix + new Date().getTime() + currCell.uid; // Generate a new ID
												currCellId = idPrefix + currCell.describe[m].uid; // Generate a new ID
												$(currCell.describe[m].elem).attr('id', currCellId);
											}
											descHeaders = (descHeaders ? descHeaders + ' ' + currCellId : currCellId);
											if (currCell.type === 5 && !$(currCell.describe[m].elem).attr('aria-describedby')) {
												var currCellId = $(currCell.elem).attr('id');
												if (currCellId === undefined || currCellId === '' || resetIds) {
													// currCellId = idPrefix + new Date().getTime() + currCell.uid; // Generate a new ID
													currCellId = idPrefix + currCell.uid; // Generate a new ID
													$(currCell.elem).attr('id', currCellId);
												}
												$(currCell.describe[m].elem).attr('aria-describedby', currCellId);
											}
										}
									}
									if (currCell.type !== 4) {
										$(currCell.elem).attr('headers', (coldataheader ? coldataheader : '') + (coldataheader && descHeaders ? ' ' : '') + (descHeaders || ''));
										if ($(currCell.elem).attr('headers') === undefined || $(currCell.elem).attr('headers') === '') {
											$(currCell.elem).removeAttr('headers');
										}
									} else if (!$(currCell.elem).attr('aria-describedby')) {
										$(currCell.elem).attr('aria-describedby', descHeaders || '');
										$(currCell.elem).attr('headers', coldataheader || '');
										if ($(currCell.elem).attr('headers') === undefined || $(currCell.elem).attr('headers') === '') {
											$(currCell.elem).removeAttr('headers');
										}
									}
								}						
							}
						}
					}

		}

        // For each table
        $('table').each(function () {

            var currentTable = this;

            // Parser the complex table
            _pe.fn.parsertable.parse($(currentTable));

            // Retrieve the parsed data
            var parsedData = $(currentTable).data().tblparser;
			
			// Fix the parsed data
			addTblHeaders(parsedData);
			
			var allSeries = [];
			
			// First rowgroup assume is a data row group. 
			// For all row....
			for (i=0;i<parsedData.lstrowgroup[0].row.length; i++) {
				var dataSeries = [],
					datacolgroupfound = 0;
				
				// For each cells
				for(j=0; j<parsedData.lstrowgroup[0].row[i].cell.length; j++){
					
					if(datacolgroupfound > 1 && parsedData.lstrowgroup[0].row[i].cell[j].col.groupstruct.type !== 2){
						break;
					}
					
					if(parsedData.lstrowgroup[0].row[i].cell[j].col.groupstruct.type === 2){
						dataSeries.push([$(parsedData.lstrowgroup[0].row[i].cell[j].col.header[0].elem).text(), getCellValue($(parsedData.lstrowgroup[0].row[i].cell[j].elem).text()).cellValue]);
						
						// dataSeries.push([datacolgroupfound, getCellValue($(parsedData.lstrowgroup[0].row[i].cell[j].elem).text()).cellValue]);
						datacolgroupfound ++;
					}
				}
				
				
				
				allSeries.push({ data: dataSeries, label: $(parsedData.lstrowgroup[0].row[i].header[0].elem).text(), color: colorsAccent[i] });
				
			}
			
			$.plot("#placeholder", allSeries, {
				series: {
					bars: {
						show: true,
						barWidth: 0.6,
						align: "center"
					}
				},
				xaxis: {
					mode: "categories",
					tickLength: 0
				}
			});



});
});
}(jQuery));
	
	</script>
</head>
<body>

	<div id="header">
		<h1>WxT Categories</h1>
	</div>

	<div id="content">

	
	<table class="wet-boew-charts wb-charts-line">
		<caption>2009 Individual Sales by Category</caption>
		<thead>
			<tr>
				<td rowspan="2"></td>
				<th colspan="2">Essential</th>
				<th colspan="3">Optional</th>
				<th rowspan="2">bath</th>
			</tr>
			<tr>
				<th>food</th>
				<th>auto</th>
				<th>household</th>
				<th>furniture</th>
				<th>kitchen</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<th>Mary</th>
				<td>300</td>
				<td>160</td>
				<td>40</td>
				<td>120</td>
				<td>100</td>
				<td>70</td>
			</tr>
			<tr>
				<th>Tom</th>
				<td>3</td>
				<td>40</td>
				<td>30</td>
				<td>45</td>
				<td>35</td>
				<td>49</td>
			</tr>
			<tr>
				<th>Brad</th>
				<td>10</td>
				<td>180</td>
				<td>10</td>
				<td>85</td>
				<td>70</td>
				<td>79</td>
			</tr>
			<tr>
				<th>Kate</th>
				<td>40</td>
				<td>80</td>
				<td>90</td>
				<td>25</td>
				<td>15</td>
				<td>119</td>
			</tr>		
		</tbody>
	</table>
	
		<div class="demo-container">
			<div id="placeholder" class="demo-placeholder"></div>
		</div>

	</div>

</body>
</html>





